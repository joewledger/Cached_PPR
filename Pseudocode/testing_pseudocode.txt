#In this file, PPR stands for Personalized Page Rank

Function: cached_PPR()

Inputs: W, Q, alpha, beta, epsilon
	#W == sparse matrix representation of graph (assumes graph is connected, undirected, and column normalized)
	#Q == indices of query nodes
	#alpha == restart probability
	#beta == cache size
	#epsilon == residual cut-off, after which we stop the power iteration

Outputs: num_iterations, wall_runtime, global_proximity_scores


def standard_PPR(W,Q,alpha,beta,epsilon):

	max_iterations = 1000;

	n = size(W);
	restartVector = Zeroes_Vector(nx1);
	restart_weight = 1 / size(Q);

	for q in Q:
		restartVector[q] = restart_weight;

	muPPrevious = 1.0;
	muPrevious = 1/(1-alpha);
	mu = 0.0;
	residue = 1;
	iter = 1;
	myK = (2 - c) / c;
	myXi = (sqrt(myK) - 1
	
		
	
	




def cached_PPR(W,Q,alpha,beta,epsilon):
	starting_vector <- COMBINE_PROXIMITY_VECTORS(proximity_vectors)
	restart_vector <- GET_RESTART_VECTOR(W,query_nodes)
	return RUN_PPR(W,starting_vector,restart_vector,alpha)